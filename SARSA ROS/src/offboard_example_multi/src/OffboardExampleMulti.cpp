#include "OffboardExampleMulti.h"
// #include "PoseWrapper.h"
#include <typeinfo>
#include <iostream>
#include <fstream>
#include <memory>
#include <chrono>
#include <map>


#include <ros/ros.h>
#include <mavros/frame_tf.h>
#include <mavros/mavros_plugin.h>
#include <GeographicLib/Geocentric.hpp>



namespace offboard_multi{

    std::map<int, Eigen::Vector3d> swarm_positions_local; //todo have a better key, something autogenerated would be cool
    ros::Subscriber swarm_lla_sub;
    ros::Publisher swarm_lla_pub;

    
    double relative_alt;


    int swarm_size = 1;
    int swarm_index = 0;
    double formation_radius = 5; //meters

    // Gradient descent parameters
    // double katt = 1;
    // double batt = 1;
    // double krep = 3.5;
    // double brep = 2.5;
    // double kdes = 1;
    // double bdes = .05;
    double katt = 2;
    double batt = .5;
    double krep = 2;
    double brep = 1;
    double kdes = .2;
    double bdes = .1;




    // Drone radius
    double quad_radius = 0.5;

    geometry_msgs::PoseStamped set_pose_local; /* set point pose to be sent to the flight computer */
    geometry_msgs::PoseStamped current_pose_local; /* current pose of the drone as received by the mavros subscriber */

    mavros_msgs::HomePosition current_home_position;
    sensor_msgs::NavSatFix current_position_global; /* current position of the agent as read by the satellite */
    sensor_msgs::NavSatFix current_fix_raw; /* current position of the agent as read by the satellite */
    nav_msgs::Odometry current_position_local; /* current local position of the agent as ready by the satellite  */

    Eigen::Vector3d current_position_ecef; /* gets updated with current_position_global */



    mavros_msgs::State current_state; /* current state. */
    mavros_msgs::SetMode offb_set_mode;
    mavros_msgs::CommandBool arm_cmd;

    ros::Subscriber state_sub;
    ros::Subscriber local_pose_sub;
    ros::Publisher local_setpose_pub;
    ros::Subscriber global_position_sub;
    ros::Subscriber raw_fix_sub;
    ros::Subscriber local_position_sub;
    ros::Publisher global_position_pub;
    ros::ServiceClient arming_client;
    ros::ServiceClient set_mode_client;
    ros::ServiceClient landing_client;
    ros::Subscriber relative_alt_sub;
    ros::Subscriber home_sub;
    ros::Publisher home_pub;




    double ros_rate = 10.0;
    ros::Time last_mode_request;
    ros::Time last_arm_request;

    void ParseOptions(int argc, char **argv){
        
        int c;

        bool swarm_index_set = false;
        bool swarm_size_set = false;

        while((c = getopt(argc, argv, "s:i:")) != -1){
            switch(c){
                case 'i':
                    swarm_index = atoi(optarg);    
                    swarm_index_set = true;
                    break;
                case 's':
                    swarm_size = atoi(optarg);
                    swarm_size_set = true;
                    break;
                default:
                    fprintf(stderr, "unrecognized option %c\n", optopt);
                    break;
            }
        }

        if(!swarm_index_set){
            std::cout << "swarm index not set, run with -i <number>" << std::endl;
        }    
        if(!swarm_size_set){
            std::cout << "swarm size not set, run with -s <number>" << std::endl;
        }
        if(!swarm_index_set || !swarm_size_set){
            exit(EXIT_FAILURE);   
        }

    }


    void Initialize(int argc, char **argv){


        //TODO how do I tell which roscore to connect to????
        //initialize ROS
        ros::init(argc, argv, "OffboardExampleMulti");
        ros::NodeHandle nh;
        
        //initialize internal ROS commmunications
        state_sub = nh.subscribe<mavros_msgs::State>
                ("mavros/state", 10, state_cb);
        local_pose_sub = nh.subscribe<geometry_msgs::PoseStamped>
                ("mavros/local_position/pose", 10, local_pose_cb); 
        local_setpose_pub = nh.advertise<geometry_msgs::PoseStamped>
                ("mavros/setpoint_position/local", 10); 
        local_position_sub = nh.subscribe<nav_msgs::Odometry>
                ("mavros/global_position/local", 10, local_position_cb); 
        global_position_sub = nh.subscribe<sensor_msgs::NavSatFix>
                ("mavros/global_position/global", 10, global_position_cb); 
        raw_fix_sub = nh.subscribe<sensor_msgs::NavSatFix>
                ("mavros/global_position/raw/fix", 10, raw_fix_cb); 
        relative_alt_sub = nh.subscribe<std_msgs::Float64>
                ("mavros/global_position/rel_alt", 10, relative_alt_cb);
    
        

        arming_client = nh.serviceClient<mavros_msgs::CommandBool>
                ("mavros/cmd/arming"); /* arming service. */
        set_mode_client = nh.serviceClient<mavros_msgs::SetMode>
                ("mavros/set_mode"); /* set mode service. */
        landing_client = nh.serviceClient<mavros_msgs::CommandBool>
                ("mavros/cmd/land"); /* landing service. */
        

        home_sub = nh.subscribe<mavros_msgs::HomePosition>
                ("mavros/home_position/home", 10, home_positin_cb);
        home_pub = nh.advertise<mavros_msgs::HomePosition>
                ("mavros/global_position/home", 10); /* receives its target location from this publisher. */
        

        swarm_lla_sub = nh.subscribe<offboard_multi::LLAIndexed>
                ("/offboard_multi/swarm_lla", 10, swarm_lla_cb);
        swarm_lla_pub = nh.advertise<offboard_multi::LLAIndexed>
                ("/offboard_multi/swarm_lla", 10);


        //connect to the flight computer
        FCUConnect();

        //change to offboard flight mode
        offb_set_mode.request.custom_mode = "OFFBOARD";

        //arm the quadrotor
        arm_cmd.request.value = true;

    
        last_mode_request = ros::Time::now();
        last_arm_request = ros::Time::now();
    }

    void Update(){

        SetModeOffboard(); 
        SetArm();


        if(current_state.armed && current_state.mode == "OFFBOARD" && swarm_positions_local.size() >= swarm_size - 1){
            // std::cout << "[Agent " << swarm_index << "] swarm_poses.size() is " << swarm_positions_local.size() << ". swarm fully establieshed." << std::endl;
            FollowFormation();

        }else{ 
            std::cout << "[Agent " << swarm_index << "] swarm comms not fully etablished. size is" << swarm_positions_local.size() << " ...waiting." << std::endl;
            
            
            //send a 'dummy' pose to prevent the FCU from timing out and dropping out of offboard mode 
            geometry_msgs::PoseStamped pose;
            pose.pose.position.x = 0;
            pose.pose.position.y = 0;
            pose.pose.position.z = 1;
            local_setpose_pub.publish(pose); //TODO replace with current_pose???            (would need some sort of init flag)
        }

        ros::spinOnce();
        ros::Rate rate(ros_rate);
        rate.sleep();    
    }


    // make the swarm orbit a circular path while avoiding each other.
    // gradient descent used for path planning
    void FollowFormation(){


        //TODO make sure the set_pose is accurately initialized first
        double set_pl[3];
        set_pl[0] = set_pose_local.pose.position.x;
        set_pl[1] = set_pose_local.pose.position.y;
        set_pl[2] = set_pose_local.pose.position.z;

        // Initialize gradient
        double fgrad[3];     // gradient of potential function
        double v[3];
        double vnorm;
        
        
        //get the positions of each other quadrotor so they can be avoided
        //obstacles
        double obs_local[3];      //obstacle position
        double d;            // distance to obstacle
        double dgrad[3];     // gradient of distance to obstacle
        double swarm_center[2];
        swarm_center[0] = current_pose_local.pose.position.x;
        swarm_center[1] = current_pose_local.pose.position.y;


        fgrad[0] = 0;
        fgrad[1] = 0;
        fgrad[2] = 0;

        //iterate over map
        for (auto it = swarm_positions_local.begin(); it != swarm_positions_local.end(); it++ ){
            
            //TODO make sure index is not self...

            obs_local[0] = it->second.x();
            obs_local[1] = it->second.y();
            obs_local[2] = it->second.z();

            swarm_center[0] += obs_local[0];
            swarm_center[1] += obs_local[1];

            v[0] = set_pl[0] - obs_local[0];
            v[1] = set_pl[1] - obs_local[1];
            v[2] = set_pl[2] - obs_local[2];


            vnorm = sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]); 

            d = vnorm - (quad_radius+quad_radius); //obstacles are other quadrotors
            if(d < 0.0){
                d = quad_radius+quad_radius;
            }


            dgrad[0] = v[0]/vnorm;
            dgrad[1] = v[1]/vnorm;
            dgrad[2] = v[2]/vnorm;

            if (d <= brep){
                fgrad[0] += -krep*(1/d-1/brep)/pow(d,2)*dgrad[0];
                fgrad[1] += -krep*(1/d-1/brep)/pow(d,2)*dgrad[1];
                fgrad[2] += -krep*(1/d-1/brep)/pow(d,2)*dgrad[2];
            }else{
                fgrad[0] += 0;
                fgrad[1] += 0;
                fgrad[2] += 0;
            }

        }
        
        swarm_center[0] /= swarm_size;
        swarm_center[1] /= swarm_size;
        

        //get the position that the quadrotor wants to be in in order to be in the circular path
        //target
        uint64_t t_micro = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
        double timestamp_micro_s = static_cast<double>(t_micro);
        double formation_position_local[3];
        double phase = (double)swarm_index/(double)swarm_size*2.0*3.14159265;
        formation_position_local[0] = formation_radius*cos(timestamp_micro_s/1000000.0/50.0*3.14159265-phase) + swarm_center[0];
        formation_position_local[1] = formation_radius*sin(timestamp_micro_s/1000000.0/50.0*3.14159265-phase) + swarm_center[1];
        formation_position_local[2] = 3.0;

        // Add attractive part of gradient
        v[0] = set_pl[0] - formation_position_local[0];
        v[1] = set_pl[1] - formation_position_local[1];
        v[2] = set_pl[2] - formation_position_local[2];
        vnorm = sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
        if (vnorm <= batt){
            fgrad[0] += katt*v[0];
            fgrad[1] += katt*v[1];
            fgrad[2] += katt*v[2];
        }else{
            fgrad[0] += batt*katt*v[0]/vnorm;
            fgrad[1] += batt*katt*v[1]/vnorm;
            fgrad[2] += batt*katt*v[2]/vnorm;
        } 


        
        
        // Take a step
        vnorm = sqrt(fgrad[0]*fgrad[0] + fgrad[1]*fgrad[1] + fgrad[2]*fgrad[2]);

        if (kdes*vnorm <= bdes){
                set_pl[0] += -kdes*fgrad[0];
                set_pl[1] += -kdes*fgrad[1];
                set_pl[2] += -kdes*fgrad[2];
        }else{
                set_pl[0] += -bdes*fgrad[0]/vnorm;
                set_pl[1] += -bdes*fgrad[1]/vnorm;
                set_pl[2] += -bdes*fgrad[2]/vnorm;
        }

        //std::cout << "set pose: " << set_p[0] << ", " << set_p[1] << ", " << set_p[2] << std::endl;
        
        set_pose_local.pose.position.x = set_pl[0];
        set_pose_local.pose.position.y = set_pl[1];
        set_pose_local.pose.position.z = set_pl[2];

        local_setpose_pub.publish(set_pose_local);
    }


    void FCUConnect(){
        
        ros::Rate rate(ros_rate);

        //connect to the flight computer
        std::cout << "connecting to the FCU" << std::endl;


        // wait for FCU connection
        while(ros::ok() && !current_state.connected){
                ros::spinOnce();
                rate.sleep();
        }

        std::cout << "FCU connected" << std::endl;


        geometry_msgs::PoseStamped pose;
        pose.pose.position.x = 0;
        pose.pose.position.y = 0;
        pose.pose.position.z = 1;
        
        //send a few setpoints before starting
        //need to to this to prep FCU for OFFBOARD mode  
        for(int i = 100; ros::ok() && i > 0; --i){
                local_setpose_pub.publish(pose);
                ros::spinOnce();
                rate.sleep();
        }
    }

    void SetModeOffboard(){
    
        //TODO put into position mode before going into offboard mode.
        //offboard mode goes back into it's most recent mode as a failsafe.

        // std::cout << "[Agent " << swarm_index << "]current state mode is: " <<  current_state.mode << std::endl;
        if( current_state.mode != "OFFBOARD" &&
            (ros::Time::now() - last_mode_request > ros::Duration(5.0))){
            if( set_mode_client.call(offb_set_mode) &&
                offb_set_mode.response.mode_sent){
                // ROS_INFO("Offboard enabled");
                std::cout << "current state mode is: " <<  current_state.mode << std::endl;


            }
            last_mode_request = ros::Time::now();
        }
    }

    void SetArm(){
        if( !current_state.armed &&
            current_state.mode == "OFFBOARD" &&
            (ros::Time::now() - last_arm_request > ros::Duration(5.0))){
            if( arming_client.call(arm_cmd) &&
                arm_cmd.response.success){
                ROS_INFO("Vehicle armed");
            }
            last_arm_request = ros::Time::now();
        }   
    }


    void state_cb(const mavros_msgs::State::ConstPtr& msg){
        current_state = *msg;
        // std::cout << "mode is: " << current_state.mode << std::endl;
    }

    void local_pose_cb(const geometry_msgs::PoseStamped::ConstPtr& msg){
        current_pose_local = *msg;

        // std::cout << "[agent " << swarm_index <<"] local pose is: " << current_pose_local.pose.position.x << ", " << current_pose_local.pose.position.y << ", " << current_pose_local.pose.position.z << std::endl;
        
    }

    void relative_alt_cb(const std_msgs::Float64::ConstPtr& msg){
        relative_alt = msg->data;
    }

    void local_position_cb(const nav_msgs::Odometry::ConstPtr& msg){
        current_position_local = *msg;
        
        // std::cout << "[agent " << swarm_index <<"] local position is: " << current_position_local.pose.pose.position.x << ", " << current_position_local.pose.pose.position.y << ", " << current_position_local.pose.pose.position.z << std::endl;
        
    }

    void global_position_cb(const sensor_msgs::NavSatFix::ConstPtr& msg){
        current_position_global = *msg;

        //then publish to swarm_lla
        // offboard_multi::LLAIndexed llai;
        // llai.index = swarm_index;
        // llai.latitude = current_position_global.latitude;
        // llai.longitude = current_position_global.longitude;
        // llai.altitude = current_position_global.altitude;
        // llai.relative_alt = relative_alt;
        // swarm_lla_pub.publish(llai);
    }

    void raw_fix_cb(const sensor_msgs::NavSatFix::ConstPtr& msg){
        current_fix_raw = *msg;

        //then publish to swarm_lla
        offboard_multi::LLAIndexed llai;
        llai.index = swarm_index;
        llai.latitude = current_fix_raw.latitude;
        llai.longitude = current_fix_raw.longitude;
        llai.altitude = current_fix_raw.altitude;
        llai.relative_alt = relative_alt;
        swarm_lla_pub.publish(llai);
    }

    void home_positin_cb(const mavros_msgs::HomePosition::ConstPtr& msg){
        current_home_position = *msg;
        
    }

    void swarm_lla_cb(const offboard_multi::LLAIndexed::ConstPtr& msg){
        offboard_multi::LLAIndexed llai = *msg;

        // extract lla (make sure not own index!)
        if(llai.index == swarm_index){
            return;
        }

        std::cout << "[agent " << std::to_string(llai.index) <<"] lla: " << std::fixed
                  << llai.latitude << ", "
                  << llai.longitude << ", "
                  << llai.altitude << std::endl;

        Eigen::Vector3d his_map_point;
        try {
			
			GeographicLib::Geocentric map(GeographicLib::Constants::WGS84_a(),
						GeographicLib::Constants::WGS84_f());


			//his lla to ECEF                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
			map.Forward(llai.latitude, llai.longitude, llai.altitude,
						his_map_point.x(), his_map_point.y(), his_map_point.z());                                                                                                                                                                                                                    

		}
		catch (const std::exception& e) {
			ROS_INFO_STREAM("GP: Caught exception: " << e.what() << std::endl);
		}
    
        std::cout << "[agent " << swarm_index <<"] lla: " << std::fixed
                  << current_fix_raw.latitude << ", "
                  << current_fix_raw.longitude << ", "
                  << current_fix_raw.altitude << std::endl;

        Eigen::Vector3d my_map_point;
        try {
			GeographicLib::Geocentric map(GeographicLib::Constants::WGS84_a(),
						GeographicLib::Constants::WGS84_f());

			// my lla to ECEF
			map.Forward(current_fix_raw.latitude, current_fix_raw.longitude, current_fix_raw.altitude,
						my_map_point.x(), my_map_point.y(), my_map_point.z());

		}
		catch (const std::exception& e) {
			ROS_INFO_STREAM("GP: Caught exception: " << e.what() << std::endl);
		}

        Eigen::Vector3d map_origin(3);
        map_origin.x() = current_home_position.geo.latitude;
        map_origin.y() = current_home_position.geo.longitude;
        map_origin.z() = current_home_position.geo.altitude;

        //subtract from own ecef position and convert to enu
        geometry_msgs::Point local_enu;
        Eigen::Vector3d relative_ecef = his_map_point - my_map_point;
        tf::pointEigenToMsg(mavros::ftf::transform_frame_ecef_enu(relative_ecef, map_origin), local_enu); 


        std::cout << "[agent " << swarm_index <<"] to [agent " << std::to_string(llai.index) << "] in local_enu: "
                  << local_enu.x << ", "
                  << local_enu.y << ", "
                  << local_enu.z << std::endl;

        //add or update swarm local position  
        
        Eigen::Vector3d his_position_local;
        his_position_local.x() = local_enu.x + current_pose_local.pose.position.x;
        his_position_local.y() = local_enu.y + current_pose_local.pose.position.y;
        his_position_local.z() = local_enu.z + current_pose_local.pose.position.z;
        
        if(swarm_positions_local.count(llai.index) == 1){ //TODO change index... 
            //index found, update it.
            swarm_positions_local[llai.index] = his_position_local;
        }else{
            //index not found, insert it.
            swarm_positions_local.insert({llai.index, his_position_local});
        }
            
    }



   
}